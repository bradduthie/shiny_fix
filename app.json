[{"name":"server.R","content":"library(shiny);\nlibrary(shinyjs) \n\nserver <- function(input, output, session) {\n  \n  fix_dataset <- function(dat){\n    mpans   <- unique(dat[,4])\n    N_mpans <- length(mpans)\n    combs   <- unique(x = cbind(dat[,4], dat[,11]))\n    keep    <- NULL\n    for(i in 1:N_mpans){\n      rel_emails <- which(combs[,1] == mpans[i])\n      email_numb <- length(rel_emails)\n      if(email_numb == 1){\n        keep    <- c(keep, rel_emails)\n      }else{\n        having  <- which(combs[,1] == mpans[i] & combs[,2] != \"\")\n        keep    <- c(keep, having)\n      }\n    }\n    new_dat <- combs[keep, ]\n    new_len <- dim(new_dat)[1]\n    rev_dat <- array(data = NA, dim = c(new_len, 11))\n    for(i in 1:new_len){\n      mpan     <- new_dat[i, 1]\n      email    <- new_dat[i, 2]\n      orig_row <- which(dat[,4] == mpan & dat[,11] == email)[1]\n      for(j in 1:11){\n        rev_dat[i, j] <- dat[orig_row, j]\n      }\n    }\n    return(rev_dat)\n  }\n  \n  # Reactive values\n  data <- reactiveValues(\n    original = NULL,\n    fixed = NULL,\n    status = \"Ready to process data.\"\n  )\n  \n  # Observe file upload\n  observeEvent(input$file, {\n    req(input$file)\n    tryCatch({\n      data$status <- \"Reading file...\"\n      df <- read.csv(input$file$datapath)\n      data$original <- df\n      data$fixed <- NULL\n      data$status <- paste(\"File uploaded successfully. Rows:\", nrow(df), \"Columns:\", ncol(df))\n    }, error = function(e) {\n      data$status <- paste(\"Error:\", e$message)\n      showNotification(paste(\"Error:\", e$message), type = \"error\")\n    })\n  })\n  \n  # Display original data\n  output$originalTable <- renderTable({\n    req(data$original)\n    head(data$original, 10)\n  })\n  \n  # Display status\n  output$status <- renderText({\n    data$status\n  })\n  \n  # Process data\n  observeEvent(input$process, {\n    req(data$original)\n    \n    tryCatch({\n      data$status <- \"Processing data... This may take a while for large files.\"\n      \n      # Process in smaller chunks if the dataset is large\n      if (nrow(data$original) > 10000) {\n        data$status <- \"Processing large file in chunks...\"\n        \n        # Process in chunks to avoid memory issues\n        chunk_size <- 5000\n        n_chunks <- ceiling(nrow(data$original) / chunk_size)\n        fixed_chunks <- list()\n        \n        for (i in 1:n_chunks) {\n          start_row <- (i-1) * chunk_size + 1\n          end_row <- min(i * chunk_size, nrow(data$original))\n          \n          data$status <- paste(\"Processing chunk\", i, \"of\", n_chunks)\n          \n          chunk <- data$original[start_row:end_row, ]\n          chunk_matrix <- as.matrix(chunk)\n          fixed_chunk <- fix_dataset(chunk_matrix)\n          fixed_chunks[[i]] <- as.data.frame(fixed_chunk)\n        }\n        \n        # Combine all chunks\n        data$fixed <- do.call(rbind, fixed_chunks)\n        colnames(data$fixed) <- colnames(data$original)\n      } else {\n        # Process normally for smaller files\n        data_matrix <- as.matrix(data$original)\n        fixed_matrix <- fix_dataset(data_matrix)\n        data$fixed <- as.data.frame(fixed_matrix)\n        colnames(data$fixed) <- colnames(data$original)\n      }\n      \n      data$status <- paste(\"Data processed successfully! Rows:\", nrow(data$fixed), \"Columns:\", ncol(data$fixed))\n      showNotification(\"Data processed successfully!\", type = \"message\")\n    }, error = function(e) {\n      data$status <- paste(\"Error:\", e$message)\n      showNotification(paste(\"Error:\", e$message), type = \"error\")\n    })\n  })\n  \n  # Display fixed data\n  output$fixedTable <- renderTable({\n    req(data$fixed)\n    head(data$fixed, 10)\n  })\n  \n  # Dynamic download button\n  output$downloadUI <- renderUI({\n    req(data$fixed)\n    actionButton(\"downloadBtn\", \"Download Fixed Data\", class = \"btn-success\")\n  })\n  \n  # Handle download\n  observeEvent(input$downloadBtn, {\n    req(data$fixed)\n    \n    tryCatch({\n      data$status <- \"Preparing download...\"\n      \n      # Process in chunks for large files\n      if (nrow(data$fixed) > 10000) {\n        data$status <- \"Preparing large file for download...\"\n        \n        # Create CSV content in chunks\n        csv_content <- paste0(paste(names(data$fixed), collapse = \",\"), \"\\n\")\n        \n        chunk_size <- 5000\n        n_chunks <- ceiling(nrow(data$fixed) / chunk_size)\n        \n        for (i in 1:n_chunks) {\n          start_row <- (i-1) * chunk_size + 1\n          end_row <- min(i * chunk_size, nrow(data$fixed))\n          \n          data$status <- paste(\"Preparing chunk\", i, \"of\", n_chunks, \"for download\")\n          \n          chunk <- data$fixed[start_row:end_row, ]\n          chunk_csv <- apply(chunk, 1, function(x) paste(x, collapse = \",\"))\n          csv_content <- paste0(csv_content, paste(chunk_csv, collapse = \"\\n\"), \"\\n\")\n        }\n      } else {\n        # For smaller files, process all at once\n        csv_content <- paste0(\n          paste(names(data$fixed), collapse = \",\"), \"\\n\",\n          paste(apply(data$fixed, 1, function(x) paste(x, collapse = \",\")), collapse = \"\\n\")\n        )\n      }\n      \n      # Generate filename\n      filename <- if (!is.null(input$file)) {\n        paste0(tools::file_path_sans_ext(input$file$name), \"_fixed.csv\")\n      } else {\n        \"fixed_data.csv\"\n      }\n      \n      # Send to JavaScript for download\n      session$sendCustomMessage(\"downloadCsv\", list(\n        content = csv_content,\n        filename = filename\n      ))\n      \n      data$status <- \"Download ready! Check your browser's download folder.\"\n      \n    }, error = function(e) {\n      data$status <- paste(\"Error preparing download:\", e$message)\n      showNotification(paste(\"Error preparing download:\", e$message), type = \"error\")\n    })\n  })\n}\n\n\n\n\n\n\n\n\n","type":"text"},{"name":"ui.R","content":"library(shiny)\nlibrary(shinyjs) \n\nui <- fluidPage(\n  useShinyjs(),\n  tags$head(\n    tags$script(HTML(\"\n      // Function to download content as CSV in chunks\n      function downloadLargeCSV(csvContent, fileName) {\n        // Create a Blob object with the CSV content\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        \n        // Create a link element\n        const link = document.createElement('a');\n        \n        // Create a URL for the Blob\n        const url = URL.createObjectURL(blob);\n        \n        // Set the link's attributes\n        link.setAttribute('href', url);\n        link.setAttribute('download', fileName);\n        link.style.visibility = 'hidden';\n        \n        // Append the link to the body, click it, and remove it\n        document.body.appendChild(link);\n        link.click();\n        \n        // Clean up\n        setTimeout(function() {\n          document.body.removeChild(link);\n          URL.revokeObjectURL(url);\n        }, 100);\n      }\n      \n      // Function to handle the download from Shiny\n      Shiny.addCustomMessageHandler('downloadCsv', function(message) {\n        downloadLargeCSV(message.content, message.filename);\n      });\n    \"))\n  ),\n  titlePanel(\"Dataset Fixer - ShinyLive Compatible (Large Files)\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file\", \"Upload CSV File\", accept = c(\".csv\")),\n      actionButton(\"process\", \"Process Data\", class = \"btn-primary\"),\n      br(), br(),\n      uiOutput(\"downloadUI\"),\n      br(),\n      helpText(\"Note: For very large files, processing may take some time.\")\n    ),\n    mainPanel(\n      h4(\"Original Data (First 10 rows)\"),\n      tableOutput(\"originalTable\"),\n      h4(\"Fixed Data (First 10 rows)\"),\n      tableOutput(\"fixedTable\"),\n      h4(\"Processing Status\"),\n      verbatimTextOutput(\"status\")\n    )\n  )\n)","type":"text"}]
